// Generated by delombok at Sun Jan 19 19:44:26 CET 2025
package com.game.engine.rendering;

import com.game.engine.GameEngine;
import com.game.engine.msc.Debug;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.LinkedList;

/**
 * SpriteRenderer is a renderer that can render images with animation
 * functionality.
 *
 * An animation is a list of sprites which are changed each "timeOnEachSprite". The Sprite Renderer can have
 * multiple animations which can be changed with the animationIndex property.
 *
 * To create a animation from a sprite sheet the Sprite.getSprites(String src, LinkedList<Rectangle> boxes).
 * Src is the sprite sheet image and the boxes are the boxes around each sprite.
 */
public class SpriteRenderer extends Renderer {
    private LinkedList<LinkedList<Sprite>> animations = new LinkedList<>();
    private boolean isInverted = false;
    /**
     * This chooses how long a sprite is displayed before next sprite is displayed
     */
    private float timeOnEachSprite = 100;
    private int spriteIndex = 0;
    private float timeOnLastSprite = 0;
    private int animationIndex = 0;

    public Sprite getCurrentSprite() {
        return animations.get(animationIndex).get(spriteIndex);
    }

    public void addAnimation(LinkedList<Sprite> sprites) {
        animations.add(sprites);
    }

    public void addSprite(Sprite sprite) {
        addSprite(sprite, animationIndex);
    }

    public void addSprite(Sprite sprite, int animationIndex) {
        if (animations.size() == 0) animations.add(new LinkedList<>());
        animations.get(animationIndex).add(sprite);
    }

    public void onAnimationDone() {
    }

    @Override
    public void update() {
        super.update();
        LinkedList<Sprite> sprites = animations.get(animationIndex);
        if (timeOnLastSprite > timeOnEachSprite) {
            // if the sprite index is greater then the amount of sprites
            // the animation is done else we set next sprite in the animation
            if (spriteIndex + 1 == sprites.size()) {
                spriteIndex = 0;
                onAnimationDone();
            } else spriteIndex++;
            timeOnLastSprite = -1;
        }
        timeOnLastSprite += (GameEngine.deltaTime * 1000);
    }

    @Override
    public void render(Graphics2D g) {
        Sprite currentSprite = getCurrentSprite();
        if (currentSprite != null) {
            if (!isInverted()) g.drawImage(currentSprite.getImage(), (int) getPos().getX(), (int) getPos().getY(), (int) transform.getGlobalScale().getX(), (int) transform.getGlobalScale().getY(), null);
             else g.drawImage(currentSprite.getImage(), (int) (getPos().getX() + transform.getGlobalScale().getX()), (int) getPos().getY(), -(int) transform.getGlobalScale().getX(), (int) transform.getGlobalScale().getY(), null);
        }
        g.drawRect((int) getPos().getX(), (int) getPos().getY(), (int) transform.getGlobalScale().getX(), (int) transform.getGlobalScale().getY());
    }



    public void setAnimations(final LinkedList<LinkedList<Sprite>> animations) {
        this.animations = animations;
    }



    public LinkedList<LinkedList<Sprite>> getAnimations() {
        return this.animations;
    }



    public boolean isInverted() {
        return this.isInverted;
    }



    public void setInverted(final boolean isInverted) {
        this.isInverted = isInverted;
    }

    /**
     * This chooses how long a sprite is displayed before next sprite is displayed
     */


    public float getTimeOnEachSprite() {
        return this.timeOnEachSprite;
    }

    /**
     * This chooses how long a sprite is displayed before next sprite is displayed
     */


    public void setTimeOnEachSprite(final float timeOnEachSprite) {
        this.timeOnEachSprite = timeOnEachSprite;
    }



    public int getAnimationIndex() {
        return this.animationIndex;
    }



    public void setAnimationIndex(final int animationIndex) {
        this.animationIndex = animationIndex;
    }
}
